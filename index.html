<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>FaceMesh IPD — Hataları Azaltılmış</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:," />
  <style>
    body{margin:0;background:#111;color:#eee;font-family:system-ui,Segoe UI,Arial}
    header{padding:12px 16px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button,input{padding:8px 12px;border-radius:8px;border:0}
    button{background:#2b8cff;color:#fff;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    #ipd{font-weight:600;margin-left:8px}
    #wrap{display:grid;place-items:center;padding:8px}
    canvas{max-width:min(96vw,960px);width:100%;height:auto;background:#000;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .warn{color:#f99}
    .calib{display:flex;gap:8px;align-items:center}
    label{opacity:.8}
  </style>

  <!-- Async/defer KULLANMIYORUZ: önce yüklenmesini istiyoruz -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
</head>
<body>
  <header>
    <button id="startBtn">Başlat</button>
    <button id="stopBtn" disabled>Durdur</button>
    <span id="ipd">IPD: -- mm</span>
    <span id="httpsWarn" class="warn" hidden>⚠ Kamera için HTTPS veya localhost gerekir.</span>
    <span id="err" class="warn"></span>
    <div class="calib">
      <label>Kalibrasyon PD (mm):</label>
      <input id="calibInput" type="number" step="0.1" min="45" max="80" placeholder="örn. 63.5" />
      <button id="calibBtn" title="Ölçüm ortalamasını bu değere eşitle">Uygula</button>
      <button id="clearCalibBtn" title="Kalibrasyonu sıfırla">Sıfırla</button>
    </div>
  </header>

  <div id="wrap">
    <canvas id="view" width="1280" height="720"></canvas>
  </div>

  <video id="video" playsinline muted style="position:fixed;opacity:0;pointer-events:none;width:0;height:0"></video>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const isHttps = location.protocol === 'https:' || location.hostname === 'localhost';
    if (!isHttps) document.getElementById('httpsWarn').hidden = false;

    const video = document.getElementById('video');
    const canvas = document.getElementById('view');
    const ctx = canvas.getContext('2d');
    const ipdEl = document.getElementById('ipd');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const errEl = document.getElementById('err');

    const calibInput = document.getElementById('calibInput');
    const calibBtn = document.getElementById('calibBtn');
    const clearCalibBtn = document.getElementById('clearCalibBtn');

    let stream = null;
    let fm = null;
    let running = false;
    let raf = null;

    // ---- Kalibrasyon katsayısı (k) ----
    // ipd_corr = k * ipd_est  (k başlangıçta 1.0)
    let k = parseFloat(localStorage.getItem('ipd_k') || '1.0');

    function saveK(newK){
      k = newK;
      localStorage.setItem('ipd_k', String(k));
    }

    // ---- Güvenli FaceMesh constructor ----
    function getFaceMeshCtor(){
      const ctor = window.FaceMesh?.FaceMesh || window.FaceMesh;
      if (typeof ctor !== 'function') {
        throw new Error('FaceMesh constructor yüklenemedi (CDN?).');
      }
      return ctor;
    }

    // Yardımcılar
    const mean2D = (pts) => {
      let sx=0, sy=0; for (const p of pts){ sx+=p.x; sy+=p.y; }
      return { x:sx/pts.length, y:sy/pts.length };
    };
    const toPx = (p, W, H) => ({ x: p.x * W, y: p.y * H });
    const irisDiameterPx = (arrPx) => {
      const d = (i,j)=>Math.hypot(arrPx[i].x-arrPx[j].x, arrPx[i].y-arrPx[j].y);
      return (d(0,2) + d(1,3) + d(2,4)) / 3;
    };
    const drawDot = (x,y,r=4) => {
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fillStyle = '#ff2d2d';
      ctx.shadowColor = '#ff2d2d';
      ctx.shadowBlur = 6;
      ctx.fill();
      ctx.shadowBlur = 0;
    };

    // ---- Kalite kontrol eşikleri ----
    const MAX_VERT_DIFF = 0.03;   // |lp.y - rp.y| / H (yüz fazla eğikse ölçümü at)
    const IRIS_RATIO_TOL = 0.35;  // |lDia - rDia| / avgDia (çok farklıysa at)
    const MIN_IRIS_PX   = 12;     // iris piksel çapı çok küçükse at (uzak/blur)

    // ---- Temporal filtre: pencere medyan + EMA ----
    const windowVals = [];
    const WINDOW_N = 21;   // medyan için pencere
    let ema = null;
    const EMA_ALPHA = 0.25;

    function pushAndFilter(val){
      windowVals.push(val);
      if (windowVals.length > WINDOW_N) windowVals.shift();

      const sorted = [...windowVals].sort((a,b)=>a-b);
      const med = sorted[Math.floor(sorted.length/2)];

      ema = (ema == null) ? med : (EMA_ALPHA*med + (1-EMA_ALPHA)*ema);
      return {med, ema};
    }

    async function openCamera() {
      const constraints = {
        audio: false,
        video: {
          width:  { ideal: 1280 },
          height: { ideal: 720 },
          facingMode: 'user',
          frameRate: { ideal: 30, max: 60 }
        }
      };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play();
    }

    async function start() {
      if (running) return;
      errEl.textContent = '';

      if (!navigator.mediaDevices?.getUserMedia) {
        errEl.textContent = 'Tarayıcı getUserMedia desteklemiyor.';
        return;
      }

      try { await openCamera(); }
      catch(e){ errEl.textContent = 'Kamera açılamadı: '+(e.message||e.name||e); return; }

      // FaceMesh
      try {
        const FaceMeshCtor = getFaceMeshCtor();
        fm = new FaceMeshCtor({
          locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
        });
      } catch(e){ errEl.textContent = e.message || e; return; }

      fm.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      fm.onResults((res) => {
        const W = canvas.width  = video.videoWidth || 1280;
        const H = canvas.height = video.videoHeight || 720;
        ctx.save();
        ctx.clearRect(0,0,W,H);
        ctx.drawImage(video, 0, 0, W, H);

        if (!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) {
          ctx.restore(); return;
        }

        const lm = res.multiFaceLandmarks[0];
        const L = [lm[468], lm[469], lm[470], lm[471], lm[472]];
        const R = [lm[473], lm[474], lm[475], lm[476], lm[477]];

        const lC = mean2D(L), rC = mean2D(R);
        const lPx = toPx(lC, W, H), rPx = toPx(rC, W, H);

        // Iris çapı px (sol/sağ)
        const LPx = L.map(p => toPx(p, W, H));
        const RPx = R.map(p => toPx(p, W, H));
        const lDia = irisDiameterPx(LPx);
        const rDia = irisDiameterPx(RPx);
        const irisDiaPx = (lDia + rDia) * 0.5;

        // ---- Kalite kontrolleri ----
        const vertDiff = Math.abs(lPx.y - rPx.y) / H; // baş eğimi
        const irisRatio = Math.abs(lDia - rDia) / Math.max(irisDiaPx, 1e-6);

        let valid = true;
        if (irisDiaPx < MIN_IRIS_PX) valid = false;
        if (vertDiff > MAX_VERT_DIFF) valid = false;
        if (irisRatio > IRIS_RATIO_TOL) valid = false;

        // mm/px (iris varsayımı)
        const mmPerPx = 11.7 / Math.max(irisDiaPx, 1e-6);

        // ---- Yalnızca yatay mesafe ----
        const ipdPxX = Math.abs(lPx.x - rPx.x);
        let ipdMmEst = ipdPxX * mmPerPx;

        // ---- Kalibrasyon katsayısı ----
        ipdMmEst = k * ipdMmEst;

        // Görsel
        drawDot(lPx.x, lPx.y, 4);
        drawDot(rPx.x, rPx.y, 4);

        let label;
        if (valid){
          const { ema:filtered } = pushAndFilter(ipdMmEst);
          const shown = (filtered ?? ipdMmEst);
          label = `IPD: ${shown.toFixed(1)} mm`;
          ipdEl.textContent = label;
        } else {
          label = `IPD: (kalitesiz kare)`;
        }

        ctx.font = '16px ui-sans-serif, system-ui, Arial';
        const w = ctx.measureText(label).width + 12;
        ctx.fillStyle = 'rgba(0,0,0,.6)';
        ctx.fillRect(8, 8, w, 26);
        ctx.fillStyle = '#fff';
        ctx.fillText(label, 14, 28);

        ctx.restore();
      });

      running = true;
      startBtn.disabled = true;
      stopBtn.disabled  = false;

      const loop = async () => {
        if (!running) return;
        try { await fm.send({ image: video }); } catch(e){}
        raf = requestAnimationFrame(loop);
      };
      loop();
    }

    function stop() {
      running = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;

      if (raf) cancelAnimationFrame(raf), raf=null;
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream=null; }
      ipdEl.textContent = 'IPD: -- mm';
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    // ---- Kalibrasyon UI ----
    calibBtn.addEventListener('click', () => {
      const target = parseFloat(calibInput.value);
      if (!isFinite(target) || target < 45 || target > 80) { alert('Geçerli bir PD gir (45–80 mm).'); return; }
      // Son medyanı biliyorsak ona göre k hesapla; bilmiyorsak 1 karelik hızlı örnekle
      const sample = (windowVals.length ? windowVals[Math.floor(windowVals.length/2)] : null) || ema;
      if (sample && isFinite(sample) && sample > 0) {
        const newK = target / sample;
        saveK(newK);
        alert(`Kalibrasyon uygulandı (k = ${newK.toFixed(4)}).`);
      } else {
        // Akış çalışırken birkaç saniye bekleyip tekrar basman daha iyi
        alert('Önce birkaç saniye ölçüm alınsın, sonra kalibre et.');
      }
    });

    clearCalibBtn.addEventListener('click', () => {
      saveK(1.0);
      alert('Kalibrasyon sıfırlandı (k = 1.0).');
    });

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
  });
  </script>
</body>
</html>
