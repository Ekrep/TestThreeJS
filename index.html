<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>FaceMesh IPD (Sadece JS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{margin:0;background:#111;color:#eee;font-family:system-ui,Segoe UI,Arial}
    header{padding:12px 16px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{padding:8px 12px;border-radius:8px;border:0;background:#2b8cff;color:#fff;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    #ipd{font-weight:600;margin-left:8px}
    #wrap{display:grid;place-items:center;padding:8px}
    canvas{max-width:min(96vw,720px);width:100%;height:auto;background:#000;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .warn{color:#f99}
  </style>
</head>
<body>
  <header>
    <button id="startBtn">Başlat</button>
    <button id="stopBtn" disabled>Durdur</button>
    <span id="ipd">IPD: -- mm</span>
    <span id="httpsWarn" class="warn" hidden>⚠ Kamera için HTTPS veya localhost gerekir.</span>
  </header>

  <div id="wrap">
    <canvas id="view" width="640" height="480"></canvas>
  </div>

  <!-- Gizli video kaynağı -->
  <video id="video" playsinline muted style="position:fixed;opacity:0;pointer-events:none;width:0;height:0"></video>

  <!-- MediaPipe -->
  <script async src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script async src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

  <script>
  (() => {
    const isHttps = location.protocol === 'https:' || location.hostname === 'localhost';
    if (!isHttps) document.getElementById('httpsWarn').hidden = false;

    const video = document.getElementById('video');
    const canvas = document.getElementById('view');
    const ctx = canvas.getContext('2d');
    const ipdEl = document.getElementById('ipd');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');

    let cam = null;
    let fm  = null;
    let running = false;
    let animReq = null;

    // Küçük yardımcılar
    const mean2D = (pts) => {
      let sx=0, sy=0; for (const p of pts){ sx+=p.x; sy+=p.y; }
      return { x:sx/pts.length, y:sy/pts.length };
    };
    const toPx = (p, W, H) => ({ x: p.x * W, y: p.y * H });

    const irisDiameterPx = (arrPx) => {
      // 5 nokta üstünden birkaç karşıt çiftin ortalaması
      const d = (i,j)=>Math.hypot(arrPx[i].x-arrPx[j].x, arrPx[i].y-arrPx[j].y);
      return (d(0,2) + d(1,3) + d(2,4)) / 3;
    };

    const drawDot = (x,y,r=4) => {
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fillStyle = '#ff2d2d';
      ctx.shadowColor = '#ff2d2d';
      ctx.shadowBlur = 6;
      ctx.fill();
      ctx.shadowBlur = 0;
    };

    async function start() {
      if (running) return;
      running = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;

      // FaceMesh hazırla
      fm = new FaceMesh.FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
      });
      fm.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,   // İris noktaları için şart
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      fm.onResults(onResults);

      // Kamera başlat
      cam = new Camera.Camera(video, {
        onFrame: async () => { await fm.send({ image: video }); },
        width: 640,
        height: 480
      });

      try {
        await cam.start();
      } catch(e) {
        console.error('Kamera başlatılamadı:', e);
        ipdEl.textContent = 'IPD: kamera izni gerekli';
        stop();
        return;
      }

      // Canvas sürekli çizim (gerekirse ek overlay efekti vs.)
      const loop = () => { animReq = requestAnimationFrame(loop); };
      loop();
    }

    function stop() {
      running = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;

      if (cam && cam.stop) cam.stop();
      if (video.srcObject) {
        for (const t of video.srcObject.getTracks()) t.stop();
        video.srcObject = null;
      }
      if (animReq) cancelAnimationFrame(animReq);
      animReq = null;
      fm = null;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ipdEl.textContent = 'IPD: -- mm';
    }

    function onResults(res) {
      const W = canvas.width  = video.videoWidth || 640;
      const H = canvas.height = video.videoHeight || 480;

      // Video frame'ini canvas'a çiz
      ctx.save();
      ctx.clearRect(0,0,W,H);
      ctx.drawImage(res.image, 0, 0, W, H);

      // Yüz yoksa çık
      if (!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) {
        ctx.restore();
        return;
      }

      const lm = res.multiFaceLandmarks[0];

      // İris indeksleri (468-472 sol, 473-477 sağ)
      const L = [lm[468], lm[469], lm[470], lm[471], lm[472]];
      const R = [lm[473], lm[474], lm[475], lm[476], lm[477]];

      // Merkezler
      const lC = mean2D(L);
      const rC = mean2D(R);

      const lPx = toPx(lC, W, H);
      const rPx = toPx(rC, W, H);

      // İris çapı piksel (ortalama)
      const LPx = L.map(p => toPx(p, W, H));
      const RPx = R.map(p => toPx(p, W, H));
      const lDia = irisDiameterPx(LPx);
      const rDia = irisDiameterPx(RPx);
      const irisDiaPx = (lDia + rDia) * 0.5;

      // mm/piksel (ortalama iris çapı ≈ 11.7 mm)
      const mmPerPx = 11.7 / Math.max(irisDiaPx, 1e-6);

      // IPD piksel → mm
      const ipdPx = Math.hypot(lPx.x - rPx.x, lPx.y - rPx.y);
      const ipdMm = ipdPx * mmPerPx;

      // Kırmızı noktalar
      drawDot(lPx.x, lPx.y, 4);
      drawDot(rPx.x, rPx.y, 4);

      // IPD overlay
      const label = `IPD: ${ipdMm.toFixed(1)} mm`;
      ctx.font = '16px ui-sans-serif, system-ui, Arial';
      ctx.fillStyle = 'rgba(0,0,0,.6)';
      ctx.fillRect(8, 8, ctx.measureText(label).width + 12, 26);
      ctx.fillStyle = '#fff';
      ctx.fillText(label, 14, 28);

      ipdEl.textContent = label;

      ctx.restore();
    }

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);

    // İsteğe bağlı: otomatik başlat (HTTPS ise)
    if (isHttps) {
      // Kullanıcı etkileşimi gerektiren tarayıcılar için butona basmak daha güvenli
      // start(); // otomatik istersen aç
    }
  })();
  </script>
</body>
</html>
