<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>IPD Ölçer – Lite + Güçlü Kart Kalibrasyon</title>
<style>
  :root{--bg:#0b0b0c;--card:#121317;--b:#2a2c34;--txt:#e8e9ee;--pri:#2b82ff}
  html,body{height:100%} body{margin:0;background:var(--bg);color:var(--txt);font:14px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #wrap{max-width:920px;margin:16px auto;padding:12px}
  h1{margin:0 0 10px;font-size:18px}
  #row{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start}
  video,canvas{max-width:100%;border:1px solid #333;border-radius:10px}
  #panel{flex:1 1 260px;min-width:260px;background:var(--card);border:1px solid var(--b);border-radius:12px;padding:12px}
  button{cursor:pointer;background:var(--pri);color:#fff;border:0;border-radius:10px;padding:10px 12px;margin:0 8px 8px 0}
  button.sec{background:#273043}
  .dot{width:10px;height:10px;border-radius:50%;display:inline-block;vertical-align:middle;margin-right:6px}
  .row{margin:8px 0} code{background:#1a1d26;padding:2px 6px;border-radius:6px}
  #log{white-space:pre-wrap;font:12px ui-monospace,Menlo,Consolas; background:#0e1117; border:1px solid #2a2c34; border-radius:8px; padding:8px; max-height:160px; overflow:auto}
  #starter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000a;backdrop-filter:blur(2px)}
  #starter .card{background:#111823;border:1px solid #2a2c34;border-radius:12px;padding:16px;max-width:420px;text-align:center}
  #starter button{cursor:pointer;background:var(--pri);color:#fff;border:0;border-radius:10px;padding:10px 16px;margin-top:10px}
</style>
</head>
<body>
<div id="wrap">
  <h1>IPD Ölçer (Lite + Güçlü Kart Kalibrasyonu)</h1>
  <div id="row">
    <div style="position:relative">
      <video id="cam" autoplay playsinline muted></video>
      <canvas id="view"></canvas>
      <!-- Kalibrasyonda rehber kutu -->
      <canvas id="guide" style="position:absolute;left:0;top:0;pointer-events:none;"></canvas>
    </div>
    <div id="panel">
      <div class="row"><span class="dot" id="qdot" style="background:#e33"></span>
        <b id="ipd">IPD: —</b>
      </div>
      <div class="row">
        <button id="btnCalibAruco" class="sec">Kalibre Et (ArUco)</button>
        <button id="btnCalibCard"  class="sec">Kalibre Et (Kart)</button>
        <button id="btnReset" class="sec">Sıfırla</button>
      </div>
      <div class="row">Kalibrasyon: <code id="scale">—</code></div>
      <div class="row">Durum: <code id="status">hazır</code></div>
      <div id="log" class="row">İpucu: Kalibrasyonda kartı yüzüne yakın ve paralel, ekrandaki rehber kutunun içine getir.</div>
    </div>
  </div>
</div>

<div id="starter">
  <div class="card">
    <div style="font-weight:600;margin-bottom:6px">Kamera izni gerekiyor</div>
    <div style="opacity:.8">HTTPS/localhost üzerinde tek dokunuşla başlar.</div>
    <button id="btnStart">Başlat</button>
  </div>
</div>

<script type="module">
/* ======= Genel yardımcılar ======= */
const logEl = document.getElementById('log'); const statusEl = document.getElementById('status');
const log = m => { logEl.textContent += "\\n"+m; logEl.scrollTop = logEl.scrollHeight; };
const setStatus = s => statusEl.textContent = s;
const setQ = c => document.getElementById('qdot').style.background = c;
const fmt = n => (n!=null && isFinite(n)) ? n.toFixed(1) : '—';
function pushMedian(win, v, N){ win.push(v); if(win.length>N) win.shift(); const s=[...win].sort((a,b)=>a-b); const m=(s.length-1)/2; return (s.length%2)? s[(s.length-1)/2] : 0.5*(s[Math.floor(m)]+s[Math.ceil(m)]); }
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

/* ======= Parametreler ======= */
const TARGET_FPS_BASE = 10;
let targetFps = TARGET_FPS_BASE, frameBudget = 1000/targetFps;
let PROC_W = 360; const MIN_PROC_W = 320;

const MARKER_MM = 60;          // ArUco kare kenarı (mm)
const CARD_W_MM = 85.60, CARD_H_MM = 53.98; const CARD_AR = CARD_W_MM/CARD_H_MM; // 1.5858
const CAL_SAMPLES = 3;

/* ======= Elemanlar ======= */
const vid = document.getElementById('cam');
const cvs = document.getElementById('view'); const ctx = cvs.getContext('2d');
const guide = document.getElementById('guide'); const gctx = guide.getContext('2d');
const ipdEl = document.getElementById('ipd'); const scaleEl = document.getElementById('scale');
const starter = document.getElementById('starter'); const btnStart = document.getElementById('btnStart');
const btnCalibAruco = document.getElementById('btnCalibAruco'); const btnCalibCard = document.getElementById('btnCalibCard'); const btnReset = document.getElementById('btnReset');

/* ======= Durum ======= */
let landmarker=null, running=false, lastTime=0, ema=null, alpha=0.25, medianWin=[], MED_N=15;
let irisMmPersonal=null, cvReady=false, cvLoading=false, currentTrack=null, avgProcMs=0;

/* ======= Device profile ======= */
function deviceKey(track){ const s=track.getSettings(); return `ipdprof:${s.deviceId||'na'}:${s.width}x${s.height}:${s.facingMode||'user'}`; }
function saveProfile(track){ if(!irisMmPersonal) return; localStorage.setItem(deviceKey(track), JSON.stringify({ irisMmPersonal, ts:Date.now() })); }
function loadProfile(track){ try{ const raw=localStorage.getItem(deviceKey(track)); if(!raw) return false; const p=JSON.parse(raw); if(p && p.irisMmPersonal>3 && p.irisMmPersonal<8){ irisMmPersonal=p.irisMmPersonal; scaleEl.textContent=`profil iris ≈ ${irisMmPersonal.toFixed(2)} mm`; return true; } }catch{} return false; }

/* ======= MediaPipe ======= */
const v2=(p)=>[p.x*cvs.width,p.y*cvs.height]; const dist=(a,b)=>Math.hypot(a[0]-b[0],a[1]-b[1]);
async function initMP(){
  setStatus("mediapipe yükleniyor…"); log("MediaPipe yükleniyor…");
  const { FaceLandmarker, FilesetResolver } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest");
  const fs = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
  landmarker = await FaceLandmarker.createFromOptions(fs, {
    baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task" },
    outputFaceBlendshapes:false, runningMode:"VIDEO", numFaces:1
  });
  setStatus("hazır"); log("MediaPipe hazır.");
}
function irisCR(lm,left=true){
  const c = left?468:473, rim = left?[469,470,471,472]:[474,475,476,477];
  const C=lm[c];
  if(C && lm[rim[0]]){
    const C2=v2(C); let R=0,n=0; for(const i of rim){ if(lm[i]){ const p=v2(lm[i]); R+=Math.hypot(p[0]-C2[0], p[1]-C2[1]); n++; } }
    return {center:C2, r:(n?R/n:0)};
  }
  const ids = left?[33,133,159,145]:[263,362,386,374];
  let sx=0, sy=0, n=0; for(const i of ids){ if(lm[i]){ sx+=lm[i].x*cvs.width; sy+=lm[i].y*cvs.height; n++; } }
  const cen = n? [sx/n, sy/n] : [0,0]; return {center:cen, r:8};
}
function faceOK(lm){
  if(!lm[33]||!lm[263]) return {ok:false, ang:999};
  const L=v2(lm[33]), R=v2(lm[263]);
  const eyeSlope = Math.abs(Math.atan2(R[1]-L[1], R[0]-L[0])*180/Math.PI);
  return {ok: eyeSlope<=20, ang: eyeSlope};
}

/* ======= Kamera ======= */
async function initCam(){
  log("Kamera açılıyor (640×360 @≤15fps)…");
  const stream = await navigator.mediaDevices.getUserMedia({
    video:{ facingMode:"user", width:{ideal:640,max:640}, height:{ideal:360,max:360}, frameRate:{ideal:15,max:15} }, audio:false
  });
  const track = stream.getVideoTracks()[0];
  try{ await track.applyConstraints({ width:{exact:640}, height:{exact:360}, frameRate:{max:15}, advanced:[{zoom:1.0},{resizeMode:"none"}] }); }catch{}
  vid.srcObject = stream; await vid.play(); currentTrack=track;
  const aspect = vid.videoWidth/vid.videoHeight;
  cvs.width = PROC_W; cvs.height = Math.round(PROC_W/aspect);
  guide.width=cvs.width; guide.height=cvs.height;
  drawGuide(false);
  log("Kamera tamam: "+JSON.stringify(track.getSettings()));
  loadProfile(track);
  // Ayar değişirse kalibrasyonu sıfırla
  let last = track.getSettings();
  setInterval(()=>{ const st=track.getSettings();
    if (st.width!==last.width || st.height!==last.height || st.zoom!==last.zoom){
      irisMmPersonal=null; ema=null; medianWin=[]; scaleEl.textContent='—';
      log("Kamera ayarı değişti → yeniden kalibrasyon gerekli.");
    } last=st;
  },1000);
}
function drawGuide(active){
  gctx.clearRect(0,0,guide.width,guide.height);
  const w=guide.width, h=guide.height;
  const gw=Math.round(w*0.6), gh=Math.round(gw/CARD_AR);
  const x=(w-gw)/2, y=(h-gh)/2;
  gctx.strokeStyle = active? "#52ffa1" : "#666";
  gctx.setLineDash([8,6]); gctx.lineWidth=2;
  gctx.strokeRect(x,y,gw,gh);
  gctx.setLineDash([]);
  gctx.fillStyle="#ffffff0d"; gctx.fillRect(x,y,gw,gh);
}

/* ======= Döngü (adaptif throttle) ======= */
function adaptPerf(ms){
  avgProcMs = avgProcMs ? 0.8*avgProcMs+0.2*ms : ms;
  if (avgProcMs>80 && targetFps>8){ targetFps=8; frameBudget=1000/targetFps; setStatus(`düşük güç (fps=${targetFps})`); }
  if (avgProcMs>120 && PROC_W>MIN_PROC_W){ PROC_W=MIN_PROC_W; const asp=vid.videoWidth/vid.videoHeight; cvs.width=PROC_W; cvs.height=Math.round(PROC_W/asp); guide.width=cvs.width; guide.height=cvs.height; drawGuide(false); setStatus(`çok düşük güç (proc_w=${PROC_W})`); }
}
function loop(t){
  if(!running) return;
  requestAnimationFrame(loop);
  if (!landmarker || !vid.videoWidth) return;
  if (t-lastTime < frameBudget) return;
  lastTime = t;

  const t0 = performance.now();
  try{
    ctx.drawImage(vid,0,0,cvs.width,cvs.height);
    const res = landmarker.detectForVideo(vid, t0);
    if (res.faceLandmarks?.length){
      const lm = res.faceLandmarks[0];
      const L=irisCR(lm,true), R=irisCR(lm,false);
      // overlay
      ctx.fillStyle="#00ffff";
      ctx.beginPath(); ctx.arc(L.center[0],L.center[1],3,0,6.283); ctx.fill();
      ctx.beginPath(); ctx.arc(R.center[0],R.center[1],3,0,6.283); ctx.fill();
      ctx.strokeStyle="#00ffff"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(L.center[0],L.center[1]); ctx.lineTo(R.center[0],R.center[1]); ctx.stroke();

      const ok = faceOK(lm);
      if(!ok.ok){ ipdEl.textContent="IPD: —"; setQ("#e39"); return; }
      const gapPx = dist(L.center,R.center);

      if(irisMmPersonal && L.r>0 && R.r>0){
        const irisRpx = 0.5*(L.r+R.r);
        const ipdMm = gapPx * (irisMmPersonal / irisRpx);
        const med = pushMedian(medianWin, ipdMm, MED_N);
        ema = (ema==null)? med : alpha*med + (1-alpha)*ema;
        ipdEl.textContent = `IPD ≈ ${fmt(ema)} mm`;
        setQ("#3ecf5e");
      } else {
        const med = pushMedian(medianWin, gapPx, MED_N);
        ema = (ema==null)? med : alpha*med + (1-alpha)*ema;
        ipdEl.textContent = `IPD(px) ≈ ${fmt(ema)}  (kalibrasyonsuz)`;
        setQ("#fb3");
      }
    } else { ipdEl.textContent="IPD: — (yüz yok)"; setQ("#e33"); }
  }catch(e){ log("Hata: "+e); }
  adaptPerf(performance.now()-t0);
}

/* ======= OpenCV (lazy) ======= */
async function ensureOpenCV(){
  if (cvReady) return true;
  if (cvLoading){ while(!cvReady) await new Promise(r=>setTimeout(r,50)); return true; }
  cvLoading=true; log("OpenCV yükleniyor…");
  await new Promise((resolve,reject)=>{
    const s=document.createElement('script'); s.src="https://docs.opencv.org/4.x/opencv.js"; s.async=true;
    s.onload=()=>{ cv['onRuntimeInitialized']=()=>{ cvReady=true; log("OpenCV hazır."); resolve(); }; };
    s.onerror=(e)=>{ log("OpenCV yüklenemedi."); reject(e); };
    document.body.appendChild(s);
  });
  return true;
}

/* ======= ArUco kalibrasyon ======= */
function computeMmPerPxFromQuad(quadPx, realWmm){
  const src=cv.matFromArray(4,1,cv.CV_32FC2, quadPx.flat());
  const w=Math.round(Math.max(
    Math.hypot(quadPx[1][0]-quadPx[0][0], quadPx[1][1]-quadPx[0][1]),
    Math.hypot(quadPx[2][0]-quadPx[3][0], quadPx[2][1]-quadPx[3][1])
  ));
  const dst=cv.matFromArray(4,1,cv.CV_32FC2,[0,0,w,0,w,w,0,w]);
  const H=cv.getPerspectiveTransform(src,dst);
  const frame=cv.imread(cvs), warped=new cv.Mat();
  cv.warpPerspective(frame, warped, H, new cv.Size(w,w));
  const mmPerPx = realWmm / w;
  src.delete(); dst.delete(); H.delete(); frame.delete(); warped.delete();
  return mmPerPx;
}
function getArucoQuad(){
  const frame=cv.imread(cvs); const gray=new cv.Mat(); cv.cvtColor(frame,gray,cv.COLOR_RGBA2GRAY,0);
  const dict=new cv.aruco_Dictionary(cv.DICT_4X4_50);
  const params=new cv.aruco_DetectorParameters();
  const detector=new cv.aruco_ArucoDetector(dict,params);
  const corners=new cv.MatVector(); const ids=new cv.Mat();
  detector.detectMarkers(gray,corners,ids);
  let quad=null;
  if(!ids.empty() && corners.size()>0){
    const c=corners.get(0); quad=[];
    for(let i=0;i<4;i++) quad.push([c.data32F[i*2], c.data32F[i*2+1]]);
  }
  frame.delete(); gray.delete(); corners.delete(); ids.delete(); params.delete();
  return quad;
}

/* ======= Güçlü Kart tespit ======= */
function orderQuad(pts){
  // pts: [[x,y],...]
  pts.sort((a,b)=>a[0]+a[1]- (b[0]+b[1])); // kaba
  const [p0, p3] = [pts[0], pts[3]];
  const [p1, p2] = pts.slice(1,3).sort((a,b)=>a[0]-b[0]);
  return [p0,p1,p3,p2]; // tl,tr,br,bl yaklaşık
}
function quadMetrics(q){
  const w1 = Math.hypot(q[1][0]-q[0][0], q[1][1]-q[0][1]);
  const w2 = Math.hypot(q[2][0]-q[3][0], q[2][1]-q[3][1]);
  const h1 = Math.hypot(q[3][0]-q[0][0], q[3][1]-q[0][1]);
  const h2 = Math.hypot(q[2][0]-q[1][0], q[2][1]-q[1][1]);
  const w=(w1+w2)/2, h=(h1+h2)/2;
  const ar = w>h? (w/h) : (h/w);
  // köşe ortogonallik ölçütü (dot prod ~0)
  const v = (a,b)=>[b[0]-a[0], b[1]-a[1]];
  const dot=(u,v)=>u[0]*v[0]+u[1]*v[1];
  const nrm=u=>Math.hypot(u[0],u[1]);
  const ang = (A,B,C)=>{ const u=v(A,B), w=v(C,B); const d=dot(u,w)/(nrm(u)*nrm(w)+1e-6); return Math.acos(clamp(d,-1,1))*180/Math.PI; };
  const a1=ang(q[0],q[1],q[2]), a2=ang(q[1],q[2],q[3]), a3=ang(q[2],q[3],q[0]), a4=ang(q[3],q[0],q[1]);
  const orthoErr = [a1,a2,a3,a4].map(a=>Math.abs(90-a)).reduce((s,x)=>s+x,0)/4;
  return {w,h,ar,orthoErr, area:w*h};
}
function getCardQuadStrong(){
  // 1) ROI: merkez %60
  const W=cvs.width, H=cvs.height;
  const rw=Math.round(W*0.60), rh=Math.round(rw/CARD_AR);
  const rx=(W-rw)>>1, ry=(H-rh)>>1;
  const src=cv.imread(cvs);
  let roi = src.roi(new cv.Rect(rx, ry, rw, rh));
  // 2) Çoklu threshold denemesi
  const gray=new cv.Mat(); cv.cvtColor(roi, gray, cv.COLOR_RGBA2GRAY, 0);
  const outQuad = [];
  for (const thr of [cv.THRESH_OTSU, -1, -2]){ // OTSU / adaptive mean / adaptive gaussian
    let bin = new cv.Mat();
    if (thr===cv.THRESH_OTSU){
      cv.threshold(gray, bin, 0, 255, cv.THRESH_BINARY|cv.THRESH_OTSU);
    } else if (thr===-1){
      cv.adaptiveThreshold(gray, bin, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 21, 5);
    } else {
      cv.adaptiveThreshold(gray, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 21, 5);
    }
    // 3) Morfoloji (küçük delikleri kapat)
    const k = cv.Mat.ones(3,3,cv.CV_8U);
    cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, k);
    // 4) Kontur → en iyi 4gen
    const contours = new cv.MatVector(); const hierarchy = new cv.Mat();
    cv.findContours(bin, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    let best=null, bestScore=-1;
    for(let i=0;i<contours.size();i++){
      const cnt = contours.get(i);
      const peri = cv.arcLength(cnt, true);
      const approx = new cv.Mat();
      cv.approxPolyDP(cnt, approx, 0.02*peri, true);
      if(approx.rows===4 && cv.isContourConvex(approx)){
        // piksel alan eşiği (ROI alanının %10..95’i)
        const area = Math.abs(cv.contourArea(approx));
        if (area < (rw*rh*0.10) || area > (rw*rh*0.95)){ approx.delete(); cnt.delete(); continue; }
        const q=[]; for(let j=0;j<4;j++){ q.push([approx.intPtr(j,0)[0]+rx, approx.intPtr(j,0)[1]+ry]); }
        const qq = orderQuad(q);
        const m = quadMetrics(qq);
        // aspect oranı ve ortogonallik skoru
        const arErr = Math.abs(m.ar - CARD_AR)/CARD_AR;           // normalize hata
        const score = (1 - Math.min(arErr,1)) * (1 - Math.min(m.orthoErr/20,1)) * (m.area);
        if (score > bestScore){ bestScore = score; best = qq; }
      }
      approx.delete(); cnt.delete();
    }
    if (best) outQuad.push(best);
    k.delete(); bin.delete(); contours.delete(); hierarchy.delete();
  }
  gray.delete(); roi.delete(); src.delete();
  // en iyi adayı seç
  if (!outQuad.length) return null;
  outQuad.sort((A,B)=>quadMetrics(B).area - quadMetrics(A).area);
  // son kalite: aspect toleransı ±12% ve ortogonallik ort.hata < 12°
  for (const q of outQuad){
    const m = quadMetrics(q);
    if (Math.abs(m.ar - CARD_AR) / CARD_AR < 0.12 && m.orthoErr < 12) return q;
  }
  // hiçbirini geçemediyse en büyüğü dön
  return outQuad[0];
}

/* ======= Kalibrasyon akışları ======= */
async function calibrateFromQuad(getQuadFn, realWmm, label){
  await ensureOpenCV();
  drawGuide(true);
  log(`${label} kalibrasyon (3 kare)…`);
  const samples=[];
  for(let k=0;k<CAL_SAMPLES;k++){
    ctx.drawImage(vid,0,0,cvs.width,cvs.height);
    const quad = getQuadFn();
    if (quad){
      const mpp = computeMmPerPxFromQuad(quad, realWmm);
      // o esnada iris r_px ölç
      const res = landmarker.detectForVideo(vid, performance.now());
      if (res.faceLandmarks?.length){
        const lm = res.faceLandmarks[0];
        const L=irisCR(lm,true), R=irisCR(lm,false);
        if (L.r>0 && R.r>0) samples.push({ mpp, rpx:0.5*(L.r+R.r) });
      }
    }
    await new Promise(r=>setTimeout(r,120));
  }
  drawGuide(false);
  if(!samples.length){ log(`${label}: aday bulunamadı.`); alert(`${label} görülmedi. Işık/paralellik artırıp rehber kutuya getir.`); return false; }
  samples.sort((a,b)=>a.rpx-b.rpx);
  const pick = samples[Math.floor(samples.length/2)];
  irisMmPersonal = pick.rpx * pick.mpp; // kişisel iris yarıçapı (mm)
  scaleEl.textContent = `iris ≈ ${irisMmPersonal.toFixed(2)} mm (${label})`;
  saveProfile(currentTrack);
  log(`${label} kalibrasyon tamam.`);
  return true;
}

/* ======= Başlat/Butonlar ======= */
async function startAll(){
  try{
    starter.style.display='none';
    await initCam(); await initMP();
    running=true; requestAnimationFrame(loop);
  }catch(e){ log("Başlatılamadı: "+e); starter.style.display=''; }
}
document.getElementById('btnStart').onclick = startAll;
document.getElementById('btnReset').onclick = ()=>{ irisMmPersonal=null; ema=null; medianWin=[]; scaleEl.textContent='—'; };
document.getElementById('btnCalibAruco').onclick = async ()=>{ await calibrateFromQuad(getArucoQuad, MARKER_MM, "ArUco"); };
document.getElementById('btnCalibCard').onclick  = async ()=>{ await calibrateFromQuad(getCardQuadStrong, CARD_W_MM, "Kart"); };

// otomatik dene (jest şartsa overlay kalır)
document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(()=>startAll().catch(()=>{}), 300); });
document.addEventListener('visibilitychange', ()=>{ running = !document.hidden; if(running) requestAnimationFrame(loop); });
</script>
</body>
</html>
