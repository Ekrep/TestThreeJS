<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>FaceMesh IPD (Doğrudan getUserMedia)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{margin:0;background:#111;color:#eee;font-family:system-ui,Segoe UI,Arial}
    header{padding:12px 16px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{padding:8px 12px;border-radius:8px;border:0;background:#2b8cff;color:#fff;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    #ipd{font-weight:600;margin-left:8px}
    #wrap{display:grid;place-items:center;padding:8px}
    canvas{max-width:min(96vw,720px);width:100%;height:auto;background:#000;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .warn{color:#f99}
  </style>
</head>
<body>
  <header>
    <button id="startBtn">Başlat</button>
    <button id="stopBtn" disabled>Durdur</button>
    <span id="ipd">IPD: -- mm</span>
    <span id="httpsWarn" class="warn" hidden>⚠ Kamera için HTTPS veya localhost gerekir.</span>
    <span id="err" class="warn"></span>
  </header>

  <div id="wrap">
    <canvas id="view" width="640" height="480"></canvas>
  </div>

  <!-- Gizli video kaynağı -->
  <video id="video" playsinline muted style="position:fixed;opacity:0;pointer-events:none;width:0;height:0"></video>

  <!-- Sadece FaceMesh (camera_utils YOK) -->
  <script async src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

  <script>
  (() => {
    const isHttps = location.protocol === 'https:' || location.hostname === 'localhost';
    if (!isHttps) document.getElementById('httpsWarn').hidden = false;

    const video = document.getElementById('video');
    const canvas = document.getElementById('view');
    const ctx = canvas.getContext('2d');
    const ipdEl = document.getElementById('ipd');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const errEl = document.getElementById('err');

    let stream = null;
    let fm = null;
    let running = false;
    let raf = null;

    const mean2D = (pts) => {
      let sx=0, sy=0; for (const p of pts){ sx+=p.x; sy+=p.y; }
      return { x:sx/pts.length, y:sy/pts.length };
    };
    const toPx = (p, W, H) => ({ x: p.x * W, y: p.y * H });
    const irisDiameterPx = (arrPx) => {
      const d = (i,j)=>Math.hypot(arrPx[i].x-arrPx[j].x, arrPx[i].y-arrPx[j].y);
      return (d(0,2) + d(1,3) + d(2,4)) / 3;
    };
    const drawDot = (x,y,r=4) => {
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fillStyle = '#ff2d2d';
      ctx.shadowColor = '#ff2d2d';
      ctx.shadowBlur = 6;
      ctx.fill();
      ctx.shadowBlur = 0;
    };

    async function openCamera() {
      // Bazı Mac’lerde arka/ön kamera seçimi fark yaratabilir:
      const constraints = {
        audio: false,
        video: {
          width: { ideal: 640 },
          height:{ ideal: 480 },
          facingMode: 'user' // Mac’te genelde fark etmez ama mobile’da ön kamera
        }
      };
      // İzin ekranı burada çıkar
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play(); // autoplay’i garanti et
      return stream;
    }

    async function start() {
      if (running) return;
      errEl.textContent = '';
      if (!isHttps) {
        errEl.textContent = 'HTTPS/localhost değil — kamera engellenebilir.';
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        errEl.textContent = 'Tarayıcı getUserMedia desteklemiyor.';
        return;
      }

      running = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;

      try {
        await openCamera();
      } catch(e) {
        console.error('Kamera açılamadı:', e);
        errEl.textContent = 'Kamera açılamadı: ' + (e.message || e.name || e);
        stop();
        return;
      }

      // FaceMesh başlat
      fm = new FaceMesh.FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
      });
      fm.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      // Render döngüsü: video karesini gönder
      const loop = async () => {
        if (!running) return;
        // canvasi video boyutuna eşitle
        const W = canvas.width = video.videoWidth || 640;
        const H = canvas.height = video.videoHeight || 480;
        try {
          await fm.send({ image: video }); // sonuç geldiğinde onResults tetiklenecek
        } catch (e) {
          console.warn('fm.send hata:', e);
        }
        raf = requestAnimationFrame(loop);
      };

      fm.onResults((res) => {
        const W = canvas.width  = video.videoWidth || 640;
        const H = canvas.height = video.videoHeight || 480;
        ctx.save();
        ctx.clearRect(0,0,W,H);
        ctx.drawImage(video, 0, 0, W, H);

        if (!res.multiFaceLandmarks || !res.multiFaceLandmarks.length) {
          ctx.restore();
          return;
        }
        const lm = res.multiFaceLandmarks[0];
        const L = [lm[468], lm[469], lm[470], lm[471], lm[472]];
        const R = [lm[473], lm[474], lm[475], lm[476], lm[477]];

        const lC = mean2D(L), rC = mean2D(R);
        const lPx = toPx(lC, W, H), rPx = toPx(rC, W, H);

        const LPx = L.map(p => toPx(p, W, H));
        const RPx = R.map(p => toPx(p, W, H));
        const irisDiaPx = (irisDiameterPx(LPx) + irisDiameterPx(RPx)) * 0.5;

        const mmPerPx = 11.7 / Math.max(irisDiaPx, 1e-6);
        const ipdPx = Math.hypot(lPx.x - rPx.x, lPx.y - rPx.y);
        const ipdMm = ipdPx * mmPerPx;

        drawDot(lPx.x, lPx.y, 4);
        drawDot(rPx.x, rPx.y, 4);

        const label = `IPD: ${ipdMm.toFixed(1)} mm`;
        ctx.font = '16px ui-sans-serif, system-ui, Arial';
        ctx.fillStyle = 'rgba(0,0,0,.6)';
        ctx.fillRect(8, 8, ctx.measureText(label).width + 12, 26);
        ctx.fillStyle = '#fff';
        ctx.fillText(label, 14, 28);
        ipdEl.textContent = label;

        ctx.restore();
      });

      loop();
    }

    function stop() {
      running = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;

      if (raf) cancelAnimationFrame(raf);
      raf = null;

      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      ipdEl.textContent = 'IPD: -- mm';
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
  })();
  </script>
</body>
</html>
