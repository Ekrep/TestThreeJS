<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>IPD Ölçer (Web)</title>
  <style>
    body { margin:0; font:14px system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#0b0b0c; color:#eee; }
    #wrap { max-width: 960px; margin: 16px auto; padding: 12px; }
    #row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    video, canvas { max-width:100%; border:1px solid #333; border-radius:8px; }
    #panel { flex:1 1 240px; min-width:260px; background:#121317; border:1px solid #2a2c34; border-radius:12px; padding:12px; }
    h1 { font-size:18px; margin:0 0 8px; }
    button { cursor:pointer; background:#2b82ff; color:#fff; border:0; border-radius:8px; padding:10px 12px; margin-right:8px; }
    button.sec { background:#273043; }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; vertical-align:middle; margin-right:6px; }
    .row { margin:8px 0; }
    code { background:#1a1d26; padding:2px 6px; border-radius:6px; }
    ul { margin:6px 0 0 18px; }
  </style>
</head>
<body>
<div id="wrap">
  <h1>IPD Ölçer (MediaPipe + ArUco / Kart kalibrasyon)</h1>
  <div id="row">
    <div>
      <video id="cam" autoplay playsinline muted></video>
      <canvas id="view"></canvas>
    </div>
    <div id="panel">
      <div class="row"><span class="dot" id="qdot" style="background:#e33"></span><b id="ipd">IPD: —</b></div>
      <div class="row">Kalite: <b id="qtxt">yok</b></div>
      <div class="row">
        <button id="start">Kamerayı Aç</button>
        <button id="calib" class="sec">ArUco ile Kalibre</button>
        <button id="card"  class="sec">Kart ile Kalibre</button>
        <button id="reset" class="sec">Sıfırla</button>
      </div>
      <div class="row">Kalibrasyon: <code id="scale">—</code></div>
      <div class="row">İpuçları:
        <ul>
          <li>Yüzünü kameraya karşı tut (±20° içinde).</li>
          <li>ArUco/kartı yüz düzlemiyle paralel tut.</li>
          <li>İyi aydınlatma, 720p+ çözünürlük.</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<!-- OpenCV.js (Aruco modülü içeren build) -->
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="cvOnReady()" ></script>
<!-- MediaPipe Tasks Vision -->
<script type="module" src="app.js"></script>
<script>
  import { FaceLandmarker, FilesetResolver }
  from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

const W = 1280, H = 720;         // hedef çözünürlük
const MARKER_MM = 60;            // ArUco kare kenarı (mm) (baskına göre değiştir)
const CARD_W_MM = 85.60, CARD_H_MM = 53.98;

const vid = document.getElementById('cam');
const cvs = document.getElementById('view');
const ctx = cvs.getContext('2d');
const ipdEl = document.getElementById('ipd');
const scaleEl = document.getElementById('scale');
const qdot = document.getElementById('qdot');
const qtxt = document.getElementById('qtxt');

let landmarker, running = false, mmPerPx = null;
let ema = null, alpha = 0.25;
let medianWin = []; const MED_N = 15;

let cvReady = false;
window.cvOnReady = () => {
  // OpenCV.js runtime hazır olduğunda çağrılır
  cv['onRuntimeInitialized'] = () => { cvReady = true; };
};

function setQuality(color, text) { qdot.style.background = color; qtxt.textContent = text; }
function fmt(n){ return (n!=null && isFinite(n)) ? n.toFixed(1) : '—'; }
function pushMedian(win, v, N){ win.push(v); if (win.length>N) win.shift();
  const s = [...win].sort((a,b)=>a-b); const m = (s.length-1)/2;
  return (s.length%2) ? s[(s.length-1)/2] : 0.5*(s[Math.floor(m)] + s[Math.ceil(m)]);
}
function v2img(p){ return [p.x*cvs.width, p.y*cvs.height]; }

async function initCam() {
  const stream = await navigator.mediaDevices.getUserMedia({
    video:{ facingMode:"user", width:{ideal:W}, height:{ideal:H}, frameRate:{ideal:30} }, audio:false
  });
  vid.srcObject = stream;
  await vid.play();
  cvs.width = vid.videoWidth || W; cvs.height = vid.videoHeight || H;
}

async function initMP() {
  const fs = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
  landmarker = await FaceLandmarker.createFromOptions(fs, {
    baseOptions: {
      modelAssetPath:
       "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task"
    },
    outputFaceBlendshapes:false, runningMode:"VIDEO", numFaces:1
  });
}

function irisCenters(lm) {
  // Önce iris merkezleri (468 sol, 473 sağ) varsa onları kullan
  const L = lm[468], R = lm[473];
  if (L && R) return { L, R, hasIris:true };
  // Yedek: göz merkezini temel kontur noktalarının ortalamasıyla tahmin et
  const idxL = [33,133,159,145], idxR = [263,362,386,374];
  const avg = (ids)=> {
    let sx=0, sy=0, n=0; for(const i of ids){ if(lm[i]){ sx+=lm[i].x; sy+=lm[i].y; n++; } }
    return {x:sx/n, y:sy/n, z:0};
  };
  return { L: avg(idxL), R: avg(idxR), hasIris:false };
}

function faceAngleQuality(lm){
  // Basit yüz-açı kestirimi: göz hattının yataya eğimi + gözler-arası/yanak genişliği oranı
  if(!lm[33] || !lm[263] || !lm[1]) return {ok:false, angle:999, qual:0};
  const [lx,ly] = v2img(lm[33]), [rx,ry] = v2img(lm[263]);
  const eyeSlopeDeg = Math.abs(Math.atan2(ry-ly, rx-lx) * 180/Math.PI); // ~0° idealdir
  const eyeDist = Math.hypot(rx-lx, ry-ly);
  const nose = v2img(lm[1]);
  const cen = [(lx+rx)/2,(ly+ry)/2];
  const off = Math.hypot(cen[0]-nose[0], cen[1]-nose[1]); // yüz merkez kayması
  // Heuristik kalite 0..1
  const qSlope = Math.max(0, 1 - eyeSlopeDeg/20);
  const qCent  = Math.max(0, 1 - off / (eyeDist*0.6));
  const qual = 0.6*qSlope + 0.4*qCent;
  const ok = (eyeSlopeDeg <= 20);
  return {ok, angle:eyeSlopeDeg, qual};
}

function drawOverlay(lm, L, R){
  ctx.fillStyle = "#00ffff"; ctx.beginPath();
  ctx.arc(L.x*cvs.width, L.y*cvs.height, 4, 0, Math.PI*2); ctx.fill();
  ctx.beginPath();
  ctx.arc(R.x*cvs.width, R.y*cvs.height, 4, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = "#00ffff"; ctx.lineWidth = 2; ctx.beginPath();
  ctx.moveTo(L.x*cvs.width, L.y*cvs.height);
  ctx.lineTo(R.x*cvs.width, R.y*cvs.height); ctx.stroke();
}

async function mainLoop() {
  if(!running) return;
  ctx.drawImage(vid, 0, 0, cvs.width, cvs.height);

  const res = landmarker.detectForVideo(vid, performance.now());
  if (res.faceLandmarks?.length) {
    const lm = res.faceLandmarks[0];
    const {L,R,hasIris} = irisCenters(lm);
    drawOverlay(lm, L, R);

    const ang = faceAngleQuality(lm);
    if (!ang.ok) { setQuality("#e39", `açı ${ang.angle.toFixed(0)}°`); ipdEl.textContent = "IPD: —"; requestAnimationFrame(mainLoop); return; }

    const [lx,ly] = v2img(L), [rx,ry] = v2img(R);
    const px = Math.hypot(rx-lx, ry-ly);
    if (mmPerPx) {
      const mm = px * mmPerPx;
      const med = pushMedian(medianWin, mm, MED_N);
      ema = (ema == null) ? med : alpha*med + (1-alpha)*ema;
      ipdEl.textContent = `IPD ≈ ${fmt(ema)} mm ${hasIris?"":"(iris≈)"}`;
      // basit uzaklık tabanlı kalite katkısı
      const distFacePx = Math.hypot((lm[1].x-0.5)*cvs.width,(lm[1].y-0.5)*cvs.height);
      const qDist = Math.max(0, 1 - distFacePx/(cvs.width*0.6));
      const q = 0.6*ang.qual + 0.4*qDist;
      const color = (q<0.4)?"#e39":((q<0.7)?"#fb3":"#3ecf5e");
      setQuality(color, q<0.4?"düşük":(q<0.7?"orta":"iyi"));
    } else {
      ipdEl.textContent = "IPD: kalibrasyon gerekli";
      setQuality("#e39", "kalibre yok");
    }
  } else {
    ipdEl.textContent = "IPD: — (yüz yok)";
    setQuality("#e33", "yok");
  }
  requestAnimationFrame(mainLoop);
}

// ---------- Kalibrasyonlar ----------
function computeMmPerPxFromQuad(quadPx, realWidthMm){
  // quadPx: [p0,p1,p2,p3] saat yönüyle; homografi ile dikdörtgeni düzelterek piksel genişliğini ölç
  const src = cv.matFromArray(4,1,cv.CV_32FC2, quadPx.flat());
  // Hedef: gerçek dünyada kare/rect; enini realWidthMm kabul edip px hedef genişliği = ölçülecek
  // Pratikte dikdörtgeni üstten görünümde yeniden örnekleyip genişliği ortalamasını alacağız
  const w = Math.round(Math.max(
      Math.hypot(quadPx[1][0]-quadPx[0][0], quadPx[1][1]-quadPx[0][1]),
      Math.hypot(quadPx[2][0]-quadPx[3][0], quadPx[2][1]-quadPx[3][1])
  ));
  const h = Math.round(Math.max(
      Math.hypot(quadPx[3][0]-quadPx[0][0], quadPx[3][1]-quadPx[0][1]),
      Math.hypot(quadPx[2][0]-quadPx[1][0], quadPx[2][1]-quadPx[1][1])
  ));
  const dst = cv.matFromArray(4,1,cv.CV_32FC2, [0,0, w,0, w,h, 0,h]);
  const H = cv.getPerspectiveTransform(src, dst);
  const frame = cv.imread(cvs); // mevcut kareden kırpma
  const warped = new cv.Mat();
  const dsize = new cv.Size(w,h);
  cv.warpPerspective(frame, warped, H, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
  // Marker genişliği piksel ~ w (üst kenar). mm/px = real_mm / px
  const mmPerPx = realWidthMm / w;
  // cleanup
  src.delete(); dst.delete(); H.delete(); frame.delete(); warped.delete();
  return mmPerPx;
}

function getArucoQuad(){
  // ArUco ile tek kare tespit: kare köşelerini döndür
  if(!cvReady) return null;
  const frame = cv.imread(cvs);
  const gray = new cv.Mat();
  cv.cvtColor(frame, gray, cv.COLOR_RGBA2GRAY, 0);
  const dict = new cv.aruco_Dictionary(cv.DICT_4X4_50);
  const params = new cv.aruco_DetectorParameters();
  const detector = new cv.aruco_ArucoDetector(dict, params);
  const corners = new cv.MatVector(); const ids = new cv.Mat();
  detector.detectMarkers(gray, corners, ids);
  let quad = null;
  if (!ids.empty() && corners.size() > 0){
    // ilk marker köşeleri (4x2 float)
    const c = corners.get(0);
    quad = [];
    for (let i=0;i<4;i++){ quad.push([c.data32F[i*2], c.data32F[i*2+1]]); }
  }
  frame.delete(); gray.delete(); corners.delete(); ids.delete(); params.delete();
  return quad;
}

function getCardQuad(){
  // Basit kart tespiti (fallback): kaba kenar bulup 4 köşe (kullanıcıyı dik tutmaya yönlendir)
  if(!cvReady) return null;
  const src = cv.imread(cvs);
  const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
  cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
  const edges = new cv.Mat(); cv.Canny(gray, edges, 50, 150);
  const contours = new cv.MatVector(); const hierarchy = new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
  let best = null, bestArea=0;
  for(let i=0;i<contours.size();i++){
    const cnt = contours.get(i);
    const peri = cv.arcLength(cnt, true);
    const approx = new cv.Mat();
    cv.approxPolyDP(cnt, approx, 0.02*peri, true);
    if (approx.rows === 4){
      const area = Math.abs(cv.contourArea(approx));
      if (area>bestArea){ bestArea=area; best=approx; }
    } else approx.delete();
    cnt.delete();
  }
  let quad = null;
  if (best){
    quad = [];
    for(let i=0;i<4;i++){ quad.push([best.intPtr(i,0)[0], best.intPtr(i,0)[1]]); }
    best.delete();
  }
  src.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();
  return quad;
}

// ---------- UI eventleri ----------
document.getElementById('start').onclick = async () => {
  await initCam(); await initMP(); running = true; requestAnimationFrame(mainLoop);
};

document.getElementById('reset').onclick = () => {
  mmPerPx = null; ema = null; medianWin = []; scaleEl.textContent = '—';
};

document.getElementById('calib').onclick = () => {
  if (!cvReady) { alert("OpenCV.js hazır değil"); return; }
  const quad = getArucoQuad();
  if (!quad){ alert("ArUco bulunamadı. Markerı kameraya net ve paralel göster."); return; }
  const mpp = computeMmPerPxFromQuad(quad, MARKER_MM);
  mmPerPx = mpp; scaleEl.textContent = `1 px = ${(mpp).toFixed(4)} mm (ArUco ${MARKER_MM}mm)`;
};

document.getElementById('card').onclick = () => {
  if (!cvReady) { alert("OpenCV.js hazır değil"); return; }
  const quad = getCardQuad();
  if (!quad){ alert("Kart bulunamadı. Kameraya paralel ve tam görünür tut."); return; }
  // kartın uzun kenarını referans al (85.60 mm)
  // (homografi sonrası üst genişlik ~ pxWidth)
  const mpp = computeMmPerPxFromQuad(quad, CARD_W_MM);
  mmPerPx = mpp; scaleEl.textContent = `1 px = ${(mpp).toFixed(4)} mm (Kart 85.60mm)`;
};
</script>
</body>
</html>
